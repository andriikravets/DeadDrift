<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Turbo Wreck</title>
<style>
  :root {
    --bg: #0a0a1a;
    --surface: #12102a;
    --accent: #ff2d7b;
    --neon-cyan: #00f0ff;
    --text: #eee;
    --text-dim: #7a7a9a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Courier New', monospace;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
  }

  #game-canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }

  /* ---- Neon glow pulse animation ---- */
  @keyframes neon-pulse {
    0%, 100% { text-shadow: 0 0 7px #ff2d7b, 0 0 20px #ff2d7b, 0 0 42px #ff2d7baa, 0 0 80px #ff2d7b55; }
    50%      { text-shadow: 0 0 4px #ff2d7b, 0 0 12px #ff2d7bcc, 0 0 28px #ff2d7b77, 0 0 50px #ff2d7b33; }
  }

  /* ---- Menu Screen ---- */
  #menu-screen {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--bg);
    z-index: 10;
  }

  /* Retro grid background */
  #menu-screen::before {
    content: '';
    position: absolute;
    inset: 0;
    background:
      repeating-linear-gradient(
        90deg,
        transparent,
        transparent 59px,
        rgba(0, 240, 255, 0.06) 59px,
        rgba(0, 240, 255, 0.06) 60px
      ),
      repeating-linear-gradient(
        0deg,
        transparent,
        transparent 59px,
        rgba(0, 240, 255, 0.06) 59px,
        rgba(0, 240, 255, 0.06) 60px
      );
    pointer-events: none;
  }

  /* Scanline overlay */
  #menu-screen::after {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.04) 2px,
      rgba(0, 0, 0, 0.04) 4px
    );
    pointer-events: none;
  }

  #menu-screen.hidden { display: none; }

  #menu-screen h1 {
    font-size: 4rem;
    color: var(--accent);
    margin-bottom: 0.25rem;
    letter-spacing: 0.5rem;
    animation: neon-pulse 2.5s ease-in-out infinite;
    position: relative;
    z-index: 1;
  }

  #menu-screen .subtitle {
    color: var(--neon-cyan);
    font-size: 0.9rem;
    margin-bottom: 2rem;
    text-transform: uppercase;
    letter-spacing: 0.35rem;
    text-shadow: 0 0 6px rgba(0, 240, 255, 0.6), 0 0 14px rgba(0, 240, 255, 0.3);
    position: relative;
    z-index: 1;
  }

  .car-selector {
    display: flex;
    gap: 12px;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
    position: relative;
    z-index: 1;
  }

  .car-card {
    background: var(--surface);
    border: 2px solid transparent;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 120px;
    transition: border-color 0.15s, box-shadow 0.15s;
    position: relative;
    z-index: 1;
  }

  .car-card:hover { border-color: rgba(0, 240, 255, 0.4); }
  .car-card.selected {
    border-color: var(--neon-cyan);
    box-shadow: 0 0 8px rgba(0, 240, 255, 0.4), inset 0 0 8px rgba(0, 240, 255, 0.08);
  }

  .car-card canvas {
    width: 80px;
    height: 80px;
    margin-bottom: 6px;
  }

  .car-card .car-name {
    font-size: 0.85rem;
    font-weight: bold;
    margin-bottom: 2px;
  }

  .car-card .car-stats {
    font-size: 0.65rem;
    color: var(--text-dim);
    text-align: center;
    line-height: 1.4;
  }

  .color-picker {
    display: flex;
    gap: 8px;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
    position: relative;
    z-index: 1;
  }

  .color-swatch {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: border-color 0.15s, transform 0.1s;
  }

  .color-swatch:hover { transform: scale(1.15); }
  .color-swatch.selected { border-color: #fff; transform: scale(1.15); }

  #start-btn {
    background: transparent;
    color: var(--accent);
    border: 2px solid var(--accent);
    padding: 12px 48px;
    font-size: 1.1rem;
    font-family: inherit;
    border-radius: 6px;
    cursor: pointer;
    letter-spacing: 0.1rem;
    text-shadow: 0 0 6px rgba(255, 45, 123, 0.5);
    transition: background 0.15s, box-shadow 0.15s, text-shadow 0.15s;
    position: relative;
    z-index: 1;
  }

  #start-btn:hover {
    background: var(--accent);
    color: #fff;
    box-shadow: 0 0 14px rgba(255, 45, 123, 0.5), 0 0 30px rgba(255, 45, 123, 0.2);
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
  }

  /* ---- HUD ---- */
  #hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    gap: 24px;
    padding: 10px 20px;
    z-index: 5;
    pointer-events: none;
  }

  #hud.hidden { display: none; }

  .hud-item {
    font-size: 0.8rem;
    color: var(--text);
  }

  .hp-bar-outer {
    width: 120px;
    height: 12px;
    background: #333;
    border-radius: 6px;
    overflow: hidden;
  }

  .hp-bar-inner {
    height: 100%;
    background: var(--accent);
    transition: width 0.15s;
  }

  /* ---- Game Over ---- */
  #game-over {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(26, 26, 46, 0.92);
    z-index: 10;
  }

  #game-over.hidden { display: none; }

  #game-over h2 {
    font-size: 2.2rem;
    color: var(--accent);
    margin-bottom: 1rem;
  }

  #game-over .stats {
    font-size: 0.9rem;
    color: var(--text-dim);
    line-height: 1.8;
    margin-bottom: 1.5rem;
    text-align: center;
  }

  #retry-btn {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 12px 48px;
    font-size: 1.1rem;
    font-family: inherit;
    border-radius: 6px;
    cursor: pointer;
    letter-spacing: 0.1rem;
    transition: opacity 0.15s;
  }

  #retry-btn:hover { opacity: 0.85; }

  /* ---- Pause Screen ---- */
  #pause-screen {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(26, 26, 46, 0.92);
    z-index: 10;
  }

  #pause-screen.hidden { display: none; }

  #pause-screen h2 {
    font-size: 2.2rem;
    color: var(--accent);
    margin-bottom: 1.5rem;
  }

  #pause-screen button {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 12px 48px;
    font-size: 1.1rem;
    font-family: inherit;
    border-radius: 6px;
    cursor: pointer;
    letter-spacing: 0.1rem;
    transition: opacity 0.15s;
    margin-bottom: 0.75rem;
  }

  #pause-screen button:hover { opacity: 0.85; }

  /* ---- Menu Resume Button ---- */
  #resume-save-btn {
    background: transparent;
    color: var(--accent);
    border: 2px solid var(--accent);
    padding: 12px 48px;
    font-size: 1.1rem;
    font-family: inherit;
    border-radius: 6px;
    cursor: pointer;
    letter-spacing: 0.1rem;
    text-shadow: 0 0 6px rgba(255, 45, 123, 0.5);
    transition: background 0.15s, box-shadow 0.15s, text-shadow 0.15s;
    margin-bottom: 0.75rem;
    position: relative;
    z-index: 1;
  }

  #resume-save-btn.hidden { display: none; }
  #resume-save-btn:hover {
    background: var(--accent);
    color: #fff;
    box-shadow: 0 0 14px rgba(255, 45, 123, 0.5), 0 0 30px rgba(255, 45, 123, 0.2);
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
  }
</style>
</head>
<body>

<canvas id="game-canvas"></canvas>

<div id="menu-screen">
  <h1>TURBO WRECK</h1>
  <p class="subtitle">survive the wasteland</p>
  <div class="car-selector" id="car-selector"></div>
  <div class="color-picker" id="color-picker"></div>
  <button id="resume-save-btn" class="hidden">RESUME</button>
  <button id="start-btn">START</button>
</div>

<div id="hud" class="hidden">
  <div class="hud-item">
    <div class="hp-bar-outer"><div class="hp-bar-inner" id="hp-bar"></div></div>
  </div>
  <div class="hud-item" id="hud-score">Score: 0</div>
  <div class="hud-item" id="hud-kills">Kills: 0</div>
  <div class="hud-item" id="hud-time">0:00</div>
</div>

<div id="pause-screen" class="hidden">
  <h2>PAUSED</h2>
  <button id="resume-btn">RESUME</button>
  <button id="quit-btn">QUIT TO MENU</button>
</div>

<div id="game-over" class="hidden">
  <h2>WRECKED</h2>
  <div class="stats" id="go-stats"></div>
  <button id="retry-btn">TRY AGAIN</button>
</div>

<script>
// ============================================================
// 1. CONFIG
// ============================================================
const CFG = {
  TILE: 8,
  CHUNK: 96,
  FIXED_DT: 1000 / 60,
  MAX_FRAME_DT: 250,
  CAMERA_LERP: 0.08,
  BIOME_SCALE: 0.0005,     // large biomes (~40+ tiles / several screens)
  MOISTURE_SCALE: 0.0007,  // moisture regions (~30 tiles)
  DETAIL_SCALE: 0.004,     // local sub-features (~5-8 tiles)
  DECORATION_CHANCE: 0.08,
  ENEMY_POOL_SIZE: 200,
  BULLET_POOL_SIZE: 100,
  BULLET_SPEED: 600,
  BULLET_MAX_AGE: 800,
  BULLET_DAMAGE: 20,
  PLAYER_RADIUS: 16,
  SPAWN_MARGIN: 150,
  BASE_SPAWN_RATE: 0.5,
  SPAWN_GROWTH: 0.02,
  MAX_SPAWN_RATE: 5,
  HIT_COOLDOWN: 600,
};

CFG.CHUNK_PX = CFG.CHUNK * CFG.TILE; // 768

const TERRAIN = {
  GRASS:    { color: '#4a7c59', rgb: [74, 124, 89],  speed: 1.0 },
  DIRT:     { color: '#8b7355', rgb: [139, 115, 85], speed: 0.95 },
  GRAVEL:   { color: '#7a7a7a', rgb: [122, 122, 122], speed: 0.85 },
  MUD:      { color: '#5c4033', rgb: [92, 64, 51],   speed: 0.70 },
  DRY_EARTH:{ color: '#c2a878', rgb: [194, 168, 120], speed: 0.9 },
};

const CAR_TYPES = {
  sedan: { name: 'Sedan',  speed: 200, turn: 3.0, hp: 100, fireRate: 250 },
  truck: { name: 'Truck',  speed: 150, turn: 2.0, hp: 180, fireRate: 400 },
  buggy: { name: 'Buggy',  speed: 280, turn: 4.0, hp: 60,  fireRate: 200 },
  suv:   { name: 'SUV',    speed: 180, turn: 2.5, hp: 140, fireRate: 300 },
};

const CAR_COLORS = [
  { name: 'Crimson',  hex: '#dc3545' },
  { name: 'Amber',    hex: '#f59e0b' },
  { name: 'Forest',   hex: '#22c55e' },
  { name: 'Cobalt',   hex: '#3b82f6' },
  { name: 'Slate',    hex: '#64748b' },
  { name: 'Obsidian', hex: '#1e1e1e' },
  { name: 'Pearl',    hex: '#e8e8e8' },
  { name: 'Rust',     hex: '#b45309' },
];

const ENEMY_TYPES = {
  shambler: { speed: 60,  hp: 40,  damage: 10, points: 10, radius: 10, color: '#8b0000' },
  runner:   { speed: 110, hp: 20,  damage: 5,  points: 25, radius: 8,  color: '#cc5500' },
  brute:    { speed: 40,  hp: 100, damage: 25, points: 50, radius: 16, color: '#4a0040' },
};

// ============================================================
// 2. SIMPLEX NOISE (Stefan Gustavson, public domain)
// ============================================================
const SimplexNoise = (() => {
  const F2 = 0.5 * (Math.sqrt(3) - 1);
  const G2 = (3 - Math.sqrt(3)) / 6;
  const grad3 = [
    [1,1],[-1,1],[1,-1],[-1,-1],
    [1,0],[-1,0],[0,1],[0,-1],
  ];

  function buildPerm(seed) {
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    // Fisher-Yates with seed
    let s = seed | 0;
    for (let i = 255; i > 0; i--) {
      s = (s * 16807 + 0) % 2147483647;
      const j = s % (i + 1);
      [p[i], p[j]] = [p[j], p[i]];
    }
    const perm = new Uint8Array(512);
    const permMod8 = new Uint8Array(512);
    for (let i = 0; i < 512; i++) {
      perm[i] = p[i & 255];
      permMod8[i] = perm[i] % 8;
    }
    return { perm, permMod8 };
  }

  function create(seed = 42) {
    const { perm, permMod8 } = buildPerm(seed);

    return function noise2D(xin, yin) {
      const s = (xin + yin) * F2;
      const i = Math.floor(xin + s);
      const j = Math.floor(yin + s);
      const t = (i + j) * G2;
      const X0 = i - t, Y0 = j - t;
      const x0 = xin - X0, y0 = yin - Y0;

      let i1, j1;
      if (x0 > y0) { i1 = 1; j1 = 0; }
      else { i1 = 0; j1 = 1; }

      const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;

      const ii = i & 255, jj = j & 255;

      let n0 = 0, n1 = 0, n2 = 0;

      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 >= 0) {
        t0 *= t0;
        const gi = permMod8[ii + perm[jj]];
        n0 = t0 * t0 * (grad3[gi][0] * x0 + grad3[gi][1] * y0);
      }

      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 >= 0) {
        t1 *= t1;
        const gi = permMod8[ii + i1 + perm[jj + j1]];
        n1 = t1 * t1 * (grad3[gi][0] * x1 + grad3[gi][1] * y1);
      }

      let t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 >= 0) {
        t2 *= t2;
        const gi = permMod8[ii + 1 + perm[jj + 1]];
        n2 = t2 * t2 * (grad3[gi][0] * x2 + grad3[gi][1] * y2);
      }

      return 70 * (n0 + n1 + n2); // [-1, 1]
    };
  }

  return { create };
})();

// ============================================================
// 3. TERRAIN MODULE
// ============================================================
const TerrainSampler = (() => {
  const biomeNoise = SimplexNoise.create(42);
  const moistureNoise = SimplexNoise.create(137);
  const detailNoise = SimplexNoise.create(255);

  function sample(wx, wy) {
    const elev = biomeNoise(wx * CFG.BIOME_SCALE, wy * CFG.BIOME_SCALE);
    const moist = moistureNoise(wx * CFG.MOISTURE_SCALE, wy * CFG.MOISTURE_SCALE);
    const d = detailNoise(wx * CFG.DETAIL_SCALE, wy * CFG.DETAIL_SCALE);

    // Detail noise perturbs the biome boundaries → organic, fractal-like edges
    const e = elev + d * 0.12;
    const m = moist + d * 0.10;

    // 2D biome selection (elevation × moisture)
    //              dry          mid           wet
    // high elev:   Gravel       Dry Earth     Grass
    // low elev:    Dry Earth    Dirt          Mud
    if (e > 0.1) {
      if (m > 0.15) return TERRAIN.GRASS;
      if (m > -0.15) return TERRAIN.DRY_EARTH;
      return TERRAIN.GRAVEL;
    } else {
      if (m > 0.15) return TERRAIN.MUD;
      if (m > -0.15) return TERRAIN.DIRT;
      return TERRAIN.DRY_EARTH;
    }
  }

  function detail(wx, wy) {
    return detailNoise(wx * CFG.DETAIL_SCALE, wy * CFG.DETAIL_SCALE);
  }

  return { sample, detail };
})();

// ============================================================
// 3b. ENEMY POOL
// ============================================================
class EnemyPool {
  constructor() {
    this.pool = Array.from({ length: CFG.ENEMY_POOL_SIZE }, () => ({
      alive: false, type: '', x: 0, y: 0, angle: 0,
      hp: 0, maxHp: 0, speed: 0, damage: 0, points: 0,
      radius: 0, color: '', hitCooldown: 0,
    }));
  }

  spawn(type, x, y) {
    const cfg = ENEMY_TYPES[type];
    if (!cfg) return null;
    for (const e of this.pool) {
      if (!e.alive) {
        e.alive = true;
        e.type = type;
        e.x = x;
        e.y = y;
        e.angle = 0;
        e.hp = cfg.hp;
        e.maxHp = cfg.hp;
        e.speed = cfg.speed;
        e.damage = cfg.damage;
        e.points = cfg.points;
        e.radius = cfg.radius;
        e.color = cfg.color;
        e.hitCooldown = 0;
        return e;
      }
    }
    return null;
  }

  forEach(fn) {
    for (const e of this.pool) {
      if (e.alive) fn(e);
    }
  }

  reset() {
    for (const e of this.pool) e.alive = false;
  }
}

// ============================================================
// 3c. BULLET POOL
// ============================================================
class BulletPool {
  constructor() {
    this.pool = Array.from({ length: CFG.BULLET_POOL_SIZE }, () => ({
      alive: false, x: 0, y: 0, dx: 0, dy: 0, angle: 0, age: 0,
      damage: CFG.BULLET_DAMAGE,
    }));
  }

  fire(x, y, angle) {
    for (const b of this.pool) {
      if (!b.alive) {
        b.alive = true;
        b.x = x;
        b.y = y;
        b.angle = angle;
        b.dx = Math.cos(angle) * CFG.BULLET_SPEED;
        b.dy = Math.sin(angle) * CFG.BULLET_SPEED;
        b.age = 0;
        return b;
      }
    }
    return null;
  }

  update(dt) {
    const dtSec = dt / 1000;
    for (const b of this.pool) {
      if (!b.alive) continue;
      b.x += b.dx * dtSec;
      b.y += b.dy * dtSec;
      b.age += dt;
      if (b.age > CFG.BULLET_MAX_AGE) b.alive = false;
    }
  }

  forEach(fn) {
    for (const b of this.pool) {
      if (b.alive) fn(b);
    }
  }

  reset() {
    for (const b of this.pool) b.alive = false;
  }
}

// ============================================================
// 3d. ENEMY MANAGER
// ============================================================
class EnemyManager {
  constructor(enemyPool) {
    this.pool = enemyPool;
    this.spawnTimer = 0;
  }

  update(dt, player, camera, canvas, elapsed) {
    const dtSec = dt / 1000;
    const elapsedSec = elapsed / 1000;

    // --- spawning ---
    const rate = Math.min(CFG.BASE_SPAWN_RATE + elapsedSec * CFG.SPAWN_GROWTH, CFG.MAX_SPAWN_RATE);
    this.spawnTimer += dtSec;
    const interval = 1 / rate;
    while (this.spawnTimer >= interval) {
      this.spawnTimer -= interval;
      this._spawnOne(player, camera, canvas, elapsedSec);
    }

    // --- AI movement + player collision ---
    this.pool.forEach(e => {
      // movement toward player
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      let targetAngle = Math.atan2(dy, dx);

      // runner zigzag
      if (e.type === 'runner') {
        targetAngle += Math.sin(elapsed * 0.004 + e.x * 0.01) * 0.5;
      }

      e.angle = targetAngle;
      e.x += Math.cos(e.angle) * e.speed * dtSec;
      e.y += Math.sin(e.angle) * e.speed * dtSec;

      // hit cooldown
      if (e.hitCooldown > 0) e.hitCooldown -= dt;

      // player collision
      const pdx = player.x - e.x;
      const pdy = player.y - e.y;
      const dist = Math.sqrt(pdx * pdx + pdy * pdy);
      if (dist < e.radius + CFG.PLAYER_RADIUS && e.hitCooldown <= 0) {
        player.takeDamage(e.damage);
        e.hp -= CFG.BULLET_DAMAGE;
        if (e.hp <= 0) {
          e.alive = false;
          player.score += e.points;
          player.kills++;
        }
        e.hitCooldown = CFG.HIT_COOLDOWN;
      }
    });

    // --- basic separation ---
    const enemies = this.pool.pool;
    for (let i = 0; i < enemies.length; i++) {
      const a = enemies[i];
      if (!a.alive) continue;
      for (let j = i + 1; j < enemies.length; j++) {
        const b = enemies[j];
        if (!b.alive) continue;
        const sx = a.x - b.x;
        const sy = a.y - b.y;
        const sd = sx * sx + sy * sy;
        if (sd < 400 && sd > 0) { // 20px
          const d = Math.sqrt(sd);
          const push = (20 - d) * 0.3;
          const nx = sx / d * push;
          const ny = sy / d * push;
          a.x += nx; a.y += ny;
          b.x -= nx; b.y -= ny;
        }
      }
    }
  }

  bulletCollision(bulletPool, player) {
    bulletPool.forEach(b => {
      this.pool.forEach(e => {
        const dx = b.x - e.x;
        const dy = b.y - e.y;
        const dist = dx * dx + dy * dy;
        const hitR = e.radius + 4;
        if (dist < hitR * hitR) {
          e.hp -= b.damage;
          b.alive = false;
          if (e.hp <= 0) {
            e.alive = false;
            player.score += e.points;
            player.kills++;
          }
        }
      });
    });
  }

  _spawnOne(player, camera, canvas, elapsedSec) {
    // pick type based on elapsed time
    const types = ['shambler'];
    if (elapsedSec > 15) types.push('runner');
    if (elapsedSec > 30) types.push('brute');
    const type = types[Math.floor(Math.random() * types.length)];

    // spawn on random viewport edge + margin
    const hw = canvas.width / 2 + CFG.SPAWN_MARGIN;
    const hh = canvas.height / 2 + CFG.SPAWN_MARGIN;
    let x, y;
    const edge = Math.floor(Math.random() * 4);
    switch (edge) {
      case 0: x = camera.x - hw; y = camera.y + (Math.random() * 2 - 1) * hh; break; // left
      case 1: x = camera.x + hw; y = camera.y + (Math.random() * 2 - 1) * hh; break; // right
      case 2: x = camera.x + (Math.random() * 2 - 1) * hw; y = camera.y - hh; break; // top
      case 3: x = camera.x + (Math.random() * 2 - 1) * hw; y = camera.y + hh; break; // bottom
    }

    this.pool.spawn(type, x, y);
  }

  reset() {
    this.pool.reset();
    this.spawnTimer = 0;
  }
}

// ============================================================
// 4. CHUNK + CHUNK MANAGER
// ============================================================
class Chunk {
  constructor(cx, cy) {
    this.cx = cx;
    this.cy = cy;
    this.worldX = cx * CFG.CHUNK_PX;
    this.worldY = cy * CFG.CHUNK_PX;
    this.decorations = [];
    this.canvas = null;
    this._build();
  }

  _build() {
    const { CHUNK, TILE } = CFG;
    const size = CFG.CHUNK_PX;
    this.canvas = document.createElement('canvas');
    this.canvas.width = size;
    this.canvas.height = size;
    const ctx = this.canvas.getContext('2d');
    const imageData = ctx.createImageData(size, size);
    const pixels = imageData.data;

    for (let ty = 0; ty < CHUNK; ty++) {
      for (let tx = 0; tx < CHUNK; tx++) {
        const wx = this.worldX + tx * TILE + TILE / 2;
        const wy = this.worldY + ty * TILE + TILE / 2;
        const terrain = TerrainSampler.sample(wx, wy);

        const d = TerrainSampler.detail(wx, wy);
        const jitter = 1.0 + d * 0.1;
        const rgb = terrain.rgb;
        const r = Math.max(0, Math.min(255, (rgb[0] * jitter + 0.5) | 0));
        const g = Math.max(0, Math.min(255, (rgb[1] * jitter + 0.5) | 0));
        const b = Math.max(0, Math.min(255, (rgb[2] * jitter + 0.5) | 0));

        const baseY = ty * TILE;
        const baseX = tx * TILE;
        for (let py = 0; py < TILE; py++) {
          let pi = ((baseY + py) * size + baseX) * 4;
          for (let px = 0; px < TILE; px++) {
            pixels[pi]     = r;
            pixels[pi + 1] = g;
            pixels[pi + 2] = b;
            pixels[pi + 3] = 255;
            pi += 4;
          }
        }

        if (Math.random() < CFG.DECORATION_CHANCE) {
          this.decorations.push({
            x: tx * TILE + Math.random() * TILE,
            y: ty * TILE + Math.random() * TILE,
            r: 1.5 + Math.random() * 2.5,
            color: this._decoColor(terrain),
          });
        }
      }
    }

    ctx.putImageData(imageData, 0, 0);

    for (const dc of this.decorations) {
      ctx.beginPath();
      ctx.arc(dc.x, dc.y, dc.r, 0, Math.PI * 2);
      ctx.fillStyle = dc.color;
      ctx.fill();
    }
  }

  _decoColor(terrain) {
    const c = terrain.color;
    const r = parseInt(c.slice(1, 3), 16);
    const g = parseInt(c.slice(3, 5), 16);
    const b = parseInt(c.slice(5, 7), 16);
    const f = 0.7 + Math.random() * 0.3;
    const clamp = v => Math.min(255, Math.max(0, Math.round(v * f)));
    return `rgb(${clamp(r)},${clamp(g)},${clamp(b)})`;
  }
}

class ChunkManager {
  constructor() {
    this.active = new Map();  // visible chunks
    this.hot = new Map();     // nearby cached
    this.cold = new Map();    // far cached (limited)
    this.coldMax = 64;
    this.genQueue = [];       // pending hot chunks to generate
    this.genSet = new Set();  // dedup for queue
  }

  _key(cx, cy) { return `${cx},${cy}`; }

  _find(key) {
    return this.active.get(key) || this.hot.get(key) || this.cold.get(key);
  }

  update(camX, camY, viewW, viewH) {
    const margin = 1; // extra chunks around viewport
    const left   = Math.floor((camX - viewW / 2) / CFG.CHUNK_PX) - margin;
    const right  = Math.floor((camX + viewW / 2) / CFG.CHUNK_PX) + margin;
    const top    = Math.floor((camY - viewH / 2) / CFG.CHUNK_PX) - margin;
    const bottom = Math.floor((camY + viewH / 2) / CFG.CHUNK_PX) + margin;

    const hotMargin = margin + 3;
    const hotLeft   = left - hotMargin;
    const hotRight  = right + hotMargin;
    const hotTop    = top - hotMargin;
    const hotBottom = bottom + hotMargin;

    const newActive = new Map();
    const newHot = new Map();

    // build active set — generate immediately if not cached
    for (let cy = top; cy <= bottom; cy++) {
      for (let cx = left; cx <= right; cx++) {
        const key = this._key(cx, cy);
        let chunk = this._find(key);
        if (!chunk) chunk = new Chunk(cx, cy);
        newActive.set(key, chunk);
        this.cold.delete(key);
        this.genSet.delete(key);
      }
    }

    // build hot set — queue generation instead of blocking
    for (let cy = hotTop; cy <= hotBottom; cy++) {
      for (let cx = hotLeft; cx <= hotRight; cx++) {
        const key = this._key(cx, cy);
        if (newActive.has(key)) continue;
        const chunk = this._find(key);
        if (chunk) {
          newHot.set(key, chunk);
        } else if (!this.genSet.has(key)) {
          this.genSet.add(key);
          this.genQueue.push({ cx, cy, key });
        }
        this.cold.delete(key);
      }
    }

    // demote old active/hot to cold
    for (const [key, chunk] of this.active) {
      if (!newActive.has(key) && !newHot.has(key)) {
        this.cold.set(key, chunk);
      }
    }
    for (const [key, chunk] of this.hot) {
      if (!newActive.has(key) && !newHot.has(key)) {
        this.cold.set(key, chunk);
      }
    }

    // trim cold cache
    if (this.cold.size > this.coldMax) {
      const keys = [...this.cold.keys()];
      while (this.cold.size > this.coldMax) {
        this.cold.delete(keys.shift());
      }
    }

    this.active = newActive;
    this.hot = newHot;

    // prune queue entries that left the hot zone
    this.genQueue = this.genQueue.filter(item => {
      if (item.cx >= hotLeft && item.cx <= hotRight &&
          item.cy >= hotTop && item.cy <= hotBottom) return true;
      this.genSet.delete(item.key);
      return false;
    });
  }

  generatePending(maxCount = 2) {
    let n = 0;
    while (this.genQueue.length > 0 && n < maxCount) {
      const { cx, cy, key } = this.genQueue.shift();
      this.genSet.delete(key);
      if (!this._find(key)) {
        this.hot.set(key, new Chunk(cx, cy));
        n++;
      }
    }
  }

  getVisible() {
    return this.active.values();
  }
}

// ============================================================
// 5. INPUT HANDLER
// ============================================================
class Input {
  constructor() {
    this.keys = new Set();
    window.addEventListener('keydown', e => {
      this.keys.add(e.code);
    });
    window.addEventListener('keyup', e => {
      this.keys.delete(e.code);
    });
    // clear on blur to avoid stuck keys
    window.addEventListener('blur', () => this.keys.clear());
  }

  isDown(code) { return this.keys.has(code); }
}

// ============================================================
// 6. CAMERA
// ============================================================
class Camera {
  constructor() {
    this.x = 0;
    this.y = 0;
  }

  follow(targetX, targetY, dt) {
    const t = 1 - Math.pow(1 - CFG.CAMERA_LERP, dt / (1000 / 60));
    this.x += (targetX - this.x) * t;
    this.y += (targetY - this.y) * t;
  }

  applyTransform(ctx, canvas) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.translate(
      Math.round(canvas.width / 2 - this.x),
      Math.round(canvas.height / 2 - this.y)
    );
  }
}

// ============================================================
// 7. PLAYER
// ============================================================
class Player {
  constructor(carType, color) {
    const cfg = CAR_TYPES[carType];
    this.carType = carType;
    this.color = color;
    this.x = 0;
    this.y = 0;
    this.angle = -Math.PI / 2; // face up
    this.speed = 0;
    this.maxSpeed = cfg.speed;
    this.turnRate = cfg.turn;
    this.hp = cfg.hp;
    this.maxHp = cfg.hp;
    this.fireRate = cfg.fireRate;
    this.score = 0;
    this.kills = 0;
    this.alive = true;
    this.fireCooldown = 0;
    this.flashTimer = 0;
  }

  update(input, dt) {
    if (!this.alive) return;
    const dtSec = dt / 1000;
    this.fireCooldown = Math.max(0, this.fireCooldown - dt);
    if (this.flashTimer > 0) this.flashTimer -= dt;

    // acceleration / braking
    if (input.isDown('ArrowUp') || input.isDown('KeyW')) {
      this.speed += 400 * dtSec;
    } else if (input.isDown('ArrowDown') || input.isDown('KeyS')) {
      this.speed -= 300 * dtSec;
    } else {
      // friction
      this.speed *= Math.pow(0.3, dtSec);
      if (Math.abs(this.speed) < 1) this.speed = 0;
    }

    // terrain speed modifier
    const terrain = TerrainSampler.sample(this.x, this.y);
    const effectiveMax = this.maxSpeed * terrain.speed;

    // clamp speed
    this.speed = Math.max(-effectiveMax * 0.4, Math.min(effectiveMax, this.speed));

    // steering (only when moving)
    if (Math.abs(this.speed) > 5) {
      const steerDir = this.speed >= 0 ? 1 : -1;
      if (input.isDown('ArrowLeft') || input.isDown('KeyA')) {
        this.angle -= this.turnRate * dtSec * steerDir;
      }
      if (input.isDown('ArrowRight') || input.isDown('KeyD')) {
        this.angle += this.turnRate * dtSec * steerDir;
      }
    }

    // move
    this.x += Math.cos(this.angle) * this.speed * dtSec;
    this.y += Math.sin(this.angle) * this.speed * dtSec;

    // score from distance
    this.score += Math.abs(this.speed) * dtSec * 0.1;
  }

  takeDamage(amount) {
    this.hp -= amount;
    this.flashTimer = 150;
    if (this.hp <= 0) {
      this.hp = 0;
      this.alive = false;
    }
  }
}

// ============================================================
// 8. CAR DRAW FUNCTIONS
// ============================================================
const CarRenderer = {
  sedan(ctx, color) {
    // body
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(-18, -10, 36, 20, 4);
    ctx.fill();
    // windshield
    ctx.fillStyle = 'rgba(150,200,255,0.5)';
    ctx.fillRect(6, -7, 8, 14);
    // wheels
    ctx.fillStyle = '#222';
    ctx.fillRect(-15, -13, 8, 3);
    ctx.fillRect(-15, 10, 8, 3);
    ctx.fillRect(8, -13, 8, 3);
    ctx.fillRect(8, 10, 8, 3);
    // headlights
    ctx.fillStyle = '#ff6';
    ctx.fillRect(17, -7, 2, 4);
    ctx.fillRect(17, 3, 2, 4);
  },

  truck(ctx, color) {
    // cab
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(2, -12, 18, 24, 3);
    ctx.fill();
    // bed
    ctx.fillStyle = shadeColor(color, -30);
    ctx.beginPath();
    ctx.roundRect(-20, -11, 22, 22, 2);
    ctx.fill();
    // windshield
    ctx.fillStyle = 'rgba(150,200,255,0.5)';
    ctx.fillRect(12, -8, 6, 16);
    // wheels (bigger)
    ctx.fillStyle = '#222';
    ctx.fillRect(-17, -15, 9, 4);
    ctx.fillRect(-17, 11, 9, 4);
    ctx.fillRect(6, -15, 9, 4);
    ctx.fillRect(6, 11, 9, 4);
    // headlights
    ctx.fillStyle = '#ff6';
    ctx.fillRect(19, -8, 2, 5);
    ctx.fillRect(19, 3, 2, 5);
  },

  buggy(ctx, color) {
    // frame
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(-14, -8, 28, 16, 6);
    ctx.fill();
    // roll cage lines
    ctx.strokeStyle = shadeColor(color, -40);
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-10, -6, 20, 12);
    // wheels (wide, exposed)
    ctx.fillStyle = '#333';
    ctx.fillRect(-14, -13, 7, 5);
    ctx.fillRect(-14, 8, 7, 5);
    ctx.fillRect(7, -13, 7, 5);
    ctx.fillRect(7, 8, 7, 5);
    // headlight bar
    ctx.fillStyle = '#ff6';
    ctx.fillRect(13, -5, 2, 10);
  },

  suv(ctx, color) {
    // body (bigger box)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(-18, -12, 36, 24, 5);
    ctx.fill();
    // roof rack
    ctx.strokeStyle = shadeColor(color, -25);
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-12, -9, 16, 18);
    // windshield
    ctx.fillStyle = 'rgba(150,200,255,0.5)';
    ctx.fillRect(8, -8, 7, 16);
    // wheels
    ctx.fillStyle = '#222';
    ctx.fillRect(-15, -15, 9, 4);
    ctx.fillRect(-15, 11, 9, 4);
    ctx.fillRect(8, -15, 9, 4);
    ctx.fillRect(8, 11, 9, 4);
    // headlights
    ctx.fillStyle = '#ff6';
    ctx.fillRect(17, -8, 2, 5);
    ctx.fillRect(17, 3, 2, 5);
  },
};

function shadeColor(hex, amount) {
  let r = parseInt(hex.slice(1, 3), 16) + amount;
  let g = parseInt(hex.slice(3, 5), 16) + amount;
  let b = parseInt(hex.slice(5, 7), 16) + amount;
  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));
  return `rgb(${r},${g},${b})`;
}

function drawCar(ctx, carType, color) {
  const fn = CarRenderer[carType];
  if (fn) fn(ctx, color);
}

// ============================================================
// 9. RENDERER
// ============================================================
class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  clear() {
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.fillStyle = '#1a1a2e';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }

  drawChunks(camera, chunkManager) {
    const ctx = this.ctx;
    for (const chunk of chunkManager.getVisible()) {
      ctx.drawImage(chunk.canvas, chunk.worldX, chunk.worldY);
    }
  }

  drawPlayer(player) {
    const ctx = this.ctx;
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    // flash white on damage
    if (player.flashTimer > 0) {
      ctx.globalAlpha = 0.5;
      drawCar(ctx, player.carType, player.color);
      ctx.globalAlpha = 0.5;
      drawCar(ctx, player.carType, '#fff');
      ctx.globalAlpha = 1;
    } else {
      drawCar(ctx, player.carType, player.color);
    }
    ctx.restore();
  }

  drawEnemies(enemyPool) {
    const ctx = this.ctx;
    enemyPool.forEach(e => {
      ctx.save();
      ctx.translate(e.x, e.y);

      // body
      ctx.beginPath();
      ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
      ctx.fillStyle = e.color;
      ctx.fill();

      // inner detail
      ctx.beginPath();
      ctx.arc(0, 0, e.radius * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fill();

      // HP bar (only when damaged)
      if (e.hp < e.maxHp) {
        const bw = e.radius * 2.5;
        const bh = 3;
        const by = -e.radius - 6;
        ctx.fillStyle = '#333';
        ctx.fillRect(-bw / 2, by, bw, bh);
        const pct = e.hp / e.maxHp;
        ctx.fillStyle = pct > 0.5 ? '#22c55e' : pct > 0.25 ? '#f59e0b' : '#e94560';
        ctx.fillRect(-bw / 2, by, bw * pct, bh);
      }

      ctx.restore();
    });
  }

  drawBullets(bulletPool) {
    const ctx = this.ctx;
    bulletPool.forEach(b => {
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);
      ctx.fillStyle = '#ffee44';
      ctx.fillRect(-2, -4, 4, 8);
      ctx.fillStyle = 'rgba(255,255,200,0.5)';
      ctx.fillRect(-1, -2, 2, 4);
      ctx.restore();
    });
  }

  drawDebug(game) {
    const ctx = this.ctx;
    const p = game.player;
    const cm = game.chunkManager;

    // count alive enemies and bullets
    let enemyAlive = 0;
    game.enemyPool.forEach(() => enemyAlive++);
    let bulletAlive = 0;
    game.bulletPool.forEach(() => bulletAlive++);

    // FPS tracking
    const now = performance.now();
    if (!this._fpsTimes) this._fpsTimes = [];
    this._fpsTimes.push(now);
    while (this._fpsTimes.length > 0 && this._fpsTimes[0] < now - 1000) this._fpsTimes.shift();
    const fps = this._fpsTimes.length;

    const lines = [
      `FPS: ${fps}`,
      `Pos: ${Math.round(p.x)}, ${Math.round(p.y)}`,
      `Chunk: ${Math.floor(p.x / CFG.CHUNK_PX)}, ${Math.floor(p.y / CFG.CHUNK_PX)}`,
      `Chunks: ${cm.active.size} act / ${cm.hot.size} hot / ${cm.cold.size} cold`,
      `Enemies: ${enemyAlive} / ${CFG.ENEMY_POOL_SIZE}`,
      `Bullets: ${bulletAlive} / ${CFG.BULLET_POOL_SIZE}`,
      `Speed: ${Math.round(p.speed)}`,
    ];

    const x = this.canvas.width - 10;
    const y = 10;
    const lineH = 16;
    const pad = 6;

    // background
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    const maxW = 240;
    ctx.fillRect(x - maxW - pad, y - pad, maxW + pad * 2, lines.length * lineH + pad * 2);

    // text
    ctx.font = '12px monospace';
    ctx.fillStyle = '#0f0';
    ctx.textAlign = 'right';
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], x, y + 12 + i * lineH);
    }
    ctx.textAlign = 'left';
  }

  render(camera, chunkManager, player, enemyPool, bulletPool, debugGame) {
    this.clear();
    camera.applyTransform(this.ctx, this.canvas);
    this.drawChunks(camera, chunkManager);
    this.drawEnemies(enemyPool);
    this.drawBullets(bulletPool);
    this.drawPlayer(player);
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (debugGame) this.drawDebug(debugGame);
  }
}

// ============================================================
// 10. HUD
// ============================================================
class HUD {
  constructor() {
    this.el = document.getElementById('hud');
    this.hpBar = document.getElementById('hp-bar');
    this.scoreEl = document.getElementById('hud-score');
    this.killsEl = document.getElementById('hud-kills');
    this.timeEl = document.getElementById('hud-time');
  }

  show() { this.el.classList.remove('hidden'); }
  hide() { this.el.classList.add('hidden'); }

  update(player, elapsedMs) {
    const pct = Math.max(0, player.hp / player.maxHp * 100);
    this.hpBar.style.width = pct + '%';

    // color shift from green → yellow → red
    if (pct > 50) this.hpBar.style.background = '#22c55e';
    else if (pct > 25) this.hpBar.style.background = '#f59e0b';
    else this.hpBar.style.background = '#e94560';

    this.scoreEl.textContent = `Score: ${Math.floor(player.score)}`;
    this.killsEl.textContent = `Kills: ${player.kills}`;

    const secs = Math.floor(elapsedMs / 1000);
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    this.timeEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
  }
}

// ============================================================
// 11. GAME (state machine + loop)
// ============================================================
const Phase = { MENU: 'menu', PLAYING: 'playing', PAUSED: 'paused', DEAD: 'dead' };

class Game {
  constructor() {
    this.phase = Phase.MENU;
    this.canvas = document.getElementById('game-canvas');
    this.renderer = new Renderer(this.canvas);
    this.input = new Input();
    this.camera = new Camera();
    this.hud = new HUD();
    this.chunkManager = null;
    this.player = null;
    this.enemyPool = new EnemyPool();
    this.bulletPool = new BulletPool();
    this.enemyManager = new EnemyManager(this.enemyPool);
    this.playStartTime = 0;
    this.elapsedMs = 0;
    this.accumulator = 0;
    this.lastTime = 0;
    this.running = false;
    this.debugOverlay = false;
    window.addEventListener('keydown', e => {
      if (e.code === 'Backquote') this.debugOverlay = !this.debugOverlay;
      if (e.code === 'Escape') {
        if (this.phase === Phase.PLAYING) this.pause();
        else if (this.phase === Phase.PAUSED) this.resume();
      }
    });
  }

  showScreen(phase) {
    document.getElementById('menu-screen').classList.toggle('hidden', phase !== Phase.MENU);
    document.getElementById('pause-screen').classList.toggle('hidden', phase !== Phase.PAUSED);
    document.getElementById('game-over').classList.toggle('hidden', phase !== Phase.DEAD);
    if (phase === Phase.PLAYING) this.hud.show();
    else this.hud.hide();
    this.phase = phase;
  }

  saveToStorage() {
    const p = this.player;
    const data = {
      player: {
        x: p.x, y: p.y, angle: p.angle, speed: p.speed,
        hp: p.hp, carType: p.carType, color: p.color,
        score: p.score, kills: p.kills,
        maxSpeed: p.maxSpeed, turnRate: p.turnRate,
        maxHp: p.maxHp, fireRate: p.fireRate,
      },
      camera: { x: this.camera.x, y: this.camera.y },
      elapsed: this.elapsedMs,
    };
    localStorage.setItem('turbowreck_save', JSON.stringify(data));
  }

  loadFromStorage() {
    const raw = localStorage.getItem('turbowreck_save');
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  clearSave() {
    localStorage.removeItem('turbowreck_save');
  }

  pause() {
    this.saveToStorage();
    this.showScreen(Phase.PAUSED);
    // loop will exit on next frame because phase !== PLAYING
  }

  resume() {
    this.showScreen(Phase.PLAYING);
    this.lastTime = performance.now();
    this.accumulator = 0;
    if (!this.running) {
      this.running = true;
      requestAnimationFrame(t => this.loop(t));
    }
  }

  quitToMenu() {
    this.clearSave();
    this.showScreen(Phase.MENU);
  }

  startFromSave(saveData) {
    const s = saveData.player;
    this.player = new Player(s.carType, s.color);
    this.player.x = s.x;
    this.player.y = s.y;
    this.player.angle = s.angle;
    this.player.speed = s.speed;
    this.player.hp = s.hp;
    this.player.score = s.score;
    this.player.kills = s.kills;
    this.player.maxSpeed = s.maxSpeed;
    this.player.turnRate = s.turnRate;
    this.player.maxHp = s.maxHp;
    this.player.fireRate = s.fireRate;
    this.camera.x = saveData.camera.x;
    this.camera.y = saveData.camera.y;
    this.chunkManager = new ChunkManager();
    this.chunkManager.update(this.camera.x, this.camera.y, this.canvas.width, this.canvas.height);
    this.enemyManager.reset();
    this.bulletPool.reset();
    this.elapsedMs = saveData.elapsed;
    this.accumulator = 0;
    this.lastTime = performance.now();
    this.showScreen(Phase.PLAYING);
    if (!this.running) {
      this.running = true;
      requestAnimationFrame(t => this.loop(t));
    }
  }

  startPlaying(carType, color) {
    this.clearSave();
    this.player = new Player(carType, color);
    this.camera.x = 0;
    this.camera.y = 0;
    this.chunkManager = new ChunkManager();
    this.chunkManager.update(0, 0, this.canvas.width, this.canvas.height);
    this.enemyManager.reset();
    this.bulletPool.reset();
    this.playStartTime = performance.now();
    this.elapsedMs = 0;
    this.accumulator = 0;
    this.lastTime = performance.now();
    this.showScreen(Phase.PLAYING);
    if (!this.running) {
      this.running = true;
      requestAnimationFrame(t => this.loop(t));
    }
  }

  die() {
    this.player.alive = false;
    this.clearSave();
    const stats = document.getElementById('go-stats');
    const secs = Math.floor(this.elapsedMs / 1000);
    const m = Math.floor(secs / 60);
    const s = secs % 60;
    stats.innerHTML = [
      `Score: ${Math.floor(this.player.score)}`,
      `Kills: ${this.player.kills}`,
      `Survived: ${m}:${s.toString().padStart(2, '0')}`,
    ].join('<br>');
    this.showScreen(Phase.DEAD);
  }

  loop(now) {
    if (this.phase !== Phase.PLAYING) {
      this.running = false;
      return;
    }

    let frameDt = now - this.lastTime;
    this.lastTime = now;
    if (frameDt > CFG.MAX_FRAME_DT) frameDt = CFG.MAX_FRAME_DT;

    this.accumulator += frameDt;
    this.elapsedMs += frameDt;

    // fixed timestep updates
    while (this.accumulator >= CFG.FIXED_DT) {
      this.fixedUpdate(CFG.FIXED_DT);
      this.accumulator -= CFG.FIXED_DT;
    }

    // render
    this.camera.follow(this.player.x, this.player.y, frameDt);
    this.chunkManager.update(this.camera.x, this.camera.y, this.canvas.width, this.canvas.height);
    this.chunkManager.generatePending(4);
    this.renderer.render(this.camera, this.chunkManager, this.player, this.enemyPool, this.bulletPool, this.debugOverlay ? this : null);
    this.hud.update(this.player, this.elapsedMs);

    requestAnimationFrame(t => this.loop(t));
  }

  fixedUpdate(dt) {
    if (this.phase !== Phase.PLAYING) return;
    this.player.update(this.input, dt);

    // shooting
    if (this.input.isDown('Space') && this.player.fireCooldown <= 0 && this.player.alive) {
      const bx = this.player.x + Math.cos(this.player.angle) * 22;
      const by = this.player.y + Math.sin(this.player.angle) * 22;
      this.bulletPool.fire(bx, by, this.player.angle);
      this.player.fireCooldown = this.player.fireRate;
    }

    // update bullets
    this.bulletPool.update(dt);

    // update enemies (spawning, AI, player collision)
    this.enemyManager.update(dt, this.player, this.camera, this.canvas, this.elapsedMs);

    // bullet-enemy collision
    this.enemyManager.bulletCollision(this.bulletPool, this.player);

    // K key → trigger death (testing)
    if (this.input.isDown('KeyK')) {
      this.player.alive = false;
    }

    if (!this.player.alive) {
      this.die();
    }
  }
}

// ============================================================
// 12. MENU WIRING
// ============================================================
function setupMenu(game) {
  let selectedCar = 'sedan';
  let selectedColor = CAR_COLORS[0].hex;

  const selectorEl = document.getElementById('car-selector');
  const colorPickerEl = document.getElementById('color-picker');

  // --- Car cards ---
  for (const [type, cfg] of Object.entries(CAR_TYPES)) {
    const card = document.createElement('div');
    card.className = 'car-card' + (type === selectedCar ? ' selected' : '');
    card.dataset.type = type;

    const preview = document.createElement('canvas');
    preview.width = 80;
    preview.height = 80;
    card.appendChild(preview);

    const nameEl = document.createElement('div');
    nameEl.className = 'car-name';
    nameEl.textContent = cfg.name;
    card.appendChild(nameEl);

    const statsEl = document.createElement('div');
    statsEl.className = 'car-stats';
    statsEl.textContent = `SPD ${cfg.speed} | TRN ${cfg.turn}\nHP ${cfg.hp}`;
    card.appendChild(statsEl);

    card.addEventListener('click', () => {
      selectorEl.querySelectorAll('.car-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      selectedCar = type;
      renderPreviews();
    });

    selectorEl.appendChild(card);
  }

  // --- Color swatches ---
  for (const c of CAR_COLORS) {
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch' + (c.hex === selectedColor ? ' selected' : '');
    swatch.style.background = c.hex;
    swatch.title = c.name;

    swatch.addEventListener('click', () => {
      colorPickerEl.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
      swatch.classList.add('selected');
      selectedColor = c.hex;
      renderPreviews();
    });

    colorPickerEl.appendChild(swatch);
  }

  function renderPreviews() {
    const cards = selectorEl.querySelectorAll('.car-card');
    cards.forEach(card => {
      const type = card.dataset.type;
      const cvs = card.querySelector('canvas');
      const ctx = cvs.getContext('2d');
      ctx.clearRect(0, 0, 80, 80);
      ctx.save();
      ctx.translate(40, 40);
      // rotate so car faces up in the preview
      ctx.rotate(-Math.PI / 2);
      const color = card.classList.contains('selected') ? selectedColor : '#666';
      drawCar(ctx, type, color);
      ctx.restore();
    });
  }

  renderPreviews();

  // --- Resume save button (menu) ---
  const resumeSaveBtn = document.getElementById('resume-save-btn');
  function updateResumeButton() {
    const save = game.loadFromStorage();
    if (save) {
      resumeSaveBtn.classList.remove('hidden');
    } else {
      resumeSaveBtn.classList.add('hidden');
    }
  }

  resumeSaveBtn.addEventListener('click', () => {
    const save = game.loadFromStorage();
    if (save) game.startFromSave(save);
  });

  // --- Start button ---
  document.getElementById('start-btn').addEventListener('click', () => {
    game.startPlaying(selectedCar, selectedColor);
  });

  // --- Retry button ---
  document.getElementById('retry-btn').addEventListener('click', () => {
    game.showScreen(Phase.MENU);
    updateResumeButton();
    renderPreviews();
  });

  // --- Pause screen buttons ---
  document.getElementById('resume-btn').addEventListener('click', () => {
    game.resume();
  });

  document.getElementById('quit-btn').addEventListener('click', () => {
    game.quitToMenu();
    updateResumeButton();
    renderPreviews();
  });

  // Check for save on initial load
  updateResumeButton();
}

// ============================================================
// 13. BOOT
// ============================================================
document.addEventListener('DOMContentLoaded', () => {
  const game = new Game();
  setupMenu(game);
});
</script>
</body>
</html>
